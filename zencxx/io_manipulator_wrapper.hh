/**
 * \file
 *
 * \brief Class \c zencxx::io_manipulator_wrapper (interface)
 *
 * \date Sun Mar 31 15:26:28 MSK 2013 -- Initial design
 */
/*
 * ZenCxx is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * ZenCxx is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.";
 */

#ifndef __ZENCXX__IO_MANIPULATOR_WRAPPER_HH__
# define __ZENCXX__IO_MANIPULATOR_WRAPPER_HH__

// Project specific includes

// Standard includes

/**
 * Function-like macro to declare a \c typedef for \c io_manipulator_wrapper<>
 * wrapped type and a helper function (manipulator) to produce it.
 *
 * \param Type a type to be wrapped
 * \param WrapperType a type of the \c io_manipulator_wrapper<> instantiation
 * \param MkWrapperName an I/O manipulator-like function name
 */
# define ZENCXX_MAKE_IOMAIP_WRAPPER_FOR(Type, WrapperType, MkWrapperName) \
    typedef zencxx::io_manipulator_wrapper<__LINE__, Type> WrapperType;   \
    inline WrapperType MkWrapperName(const Type& r)                       \
    {                                                                     \
        return WrapperType(r);                                            \
    }

namespace zencxx {

/**
 * \brief Helper class to produce wrappers used to create manipulators like
 * functions for various types.
 *
 * The idea is to provide an \b unique type, with binded reference inside, to some type \c T
 * (a wrapper type). Then one may provide an \c operator<< for such a wrapper(s) in
 * different ways (to add manipulator-like behaviour).
 *
 * For example, if there is some struct w/ lot of fields, and we want to have a short
 * output when streamming it, but sometimes long, we can define I/O manipulator to print
 * a \e short form like this (assuming default \c operator<< for that structure will
 * print everything -- i.e. long form):
 *
 * \code
 *  struct some
 *  {
 *    // a lot of members here
 *  };
 *
 *  // define unique type to overload operator<< [1]
 *  typedef zencxx::io_manipulator_wrapper<__LINE__, some> short_some_io_manip;
 *
 *  // define a helper function to produce such wrappers using ADL [2]
 *  short_some_io_manip output_short(const some& s) {
 *    return short_some_io_manip(s);
 *  }
 *
 *  // and finally overload to print a short version of some struct
 *  std::ostream& operator<<(std::ostream& os, const short_some_io_manip& sw) {
 *    os << sw.ref().m_some_member << ... ;
 *    return os;
 *  }
 *
 *  // Now it can be used like this:
 *  some s = ...;
 *  std::cout << output_short(s) << ...;
 * \endcode
 *
 * Using similar approach for other types will result in a series of overloaded
 * functions (I/O manipulators) probably in a different namespaces (so ADL can be used)
 * which give you a unified way to print your structures in a short/long (or any other kind) from.
 * So if you have a vast of structures to print any of them in a \e short form you can use
 * the "same" manipulator, named \c output_short.
 *
 * Wrapped type <em>[1]</em> and a helper function <em>[2]</em>, to produce it, can
 * be generated by a macro \c ZENCXX_MAKE_IOMAIP_WRAPPER_FOR.
 *
 * \sa \c ZENCXX_MAKE_IOMAIP_WRAPPER_FOR
 */
template <int Dummy, typename T>
class io_manipulator_wrapper
{
    /// A reference to the wrapped instance of \c T
    const T& m_ref;

public:
    /// Make an instance using a reference to \c T
    explicit io_manipulator_wrapper(const T& r) : m_ref(r) {}
    /// Give a stored reference to outer world
    const T& ref() const
    {
        return m_ref;
    }
};

}                                                           // namespace zencxx
#endif                                                      // __ZENCXX__IO_MANIPULATOR_WRAPPER_HH__
